agcov(x)
d=0.99
f0 = (1-((1-d)^(1/neff(x))))/(1-((1-agcov(x))^(1/neff(x))))
#f = d/agcov(x)
f = (d/agcov(x))^1.5
x*f0
xf = x*f
xf
#xf = xf/max(1,(max(xf)))*0.95
#xf = 1-(1-x)/f
xf = pmin(xf,0.99)
xf
agcov(xf)
ff = log(1-d)/log(1-agcov(xf))
xff = 1-exp(ff*log(1-xf))
xff
agcov(xff)
ff2 = log(1-d)/log(1-agcov(x))
xff2 = 1-exp(ff2*log(1-x))
agcov(xff2)
xff2
x/max(x)
xf/max(xf)
xff/(max(xff))
xff2/(max(xff2))
xf
xf = x*f
xf
(1-((1-d)^(1/neff(x))))/(1-((1-agcov(x))^(1/neff(x))))
d/agcov(x)
(d/agcov(x))^1.5
n = 100
x <- c(1:n)*0+1/n
agg.cover <- function(cover,max.overlap){
geometriccover <- 1-exp(sum(log(1-cover)))
linearcover <- sum(cover*(1-max.overlap))
total.cover = geometriccover*(1-linearcover)+linearcover
return(total.cover)
}
n = 100
x <- c(1:n)*0+1/n
y=agg.cover(x)
y
max.overlap=1
n = 100
x <- c(1:n)*0+1/n
y=agg.cover(x)
y
y=agg.cover(x,max.overlap)
y
n = 50
x <- c(1:n)*0+1/n
y=agg.cover(x,max.overlap)
y
p = 0.1
n = 50
x <- c(1:n)*0+p
y=agg.cover(x,max.overlap)
y
max.overlap=1
crown.width=30
treesperha = 100
coverpertree = (crown.width/2)^2*3.141892/10000
(crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
max.overlap=1
crown.width=30
treesperha = 100
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=30
treesperha = 50
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=10
treesperha = 50
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
f10 = 7
fba = 10*f10
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
diam = 35
m2pertree = 3.141592*(diam/200)^2
treesperha = mba/m2pertree
cover = 0.8
coverpertree = 1-(1-cover)^0.5
coverpertree
areapertree = coverpertree*10000/treesperha
crown.width = (areapertree/3.141592)^0.5*2
crown.width
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=10
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
treesperha
crown.width=15
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=12
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=11
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=11.2
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
crown.width=11.1
coverpertreeperha = (crown.width/2)^2*3.141892/10000
coverperha = 1-(1-coverpertreeperha)^treesperha
coverperha
f10 = 7
fba = 10*f10
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
diam = 35
m2pertree = 3.141592*(diam/200)^2
treesperha = mba/m2pertree
cover = 0.8
coverpertree = 1-(1-cover)^0.5
coverpertree
areapertree = coverpertree*10000/treesperha
crown.width = (areapertree/3.141592)^0.5*2
crown.width
coverpertreeperha
coverperha
treesperha
coverperha
treesperha
coverpertreeperha = 1-(1-coverperha)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
coverperha = 0.8
treesperha
coverpertreeperha = 1-(1-coverperha)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
cover = 0.8
treesperha
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/diam*100
crown.stem.ratio
get.crown.diam.ratio <- function(cover, dbh, ba, baf){
#cover = aggregate overstory cover
#diam = stand quadratic mean diameter
#ba = stand basal area count
#baf = basal area factor
if(is.na(baf)){baf=10}
if(baf %in% c(5,10,20,40)){#legacy basal area units
fba = baf*ba
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
}
if(is.na(baf)|baf==2){#metric basal area units
mba = ba*baf
}
m2pertree = 3.141592*(dbh/200)^2
treesperha = mba/m2pertree
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/dbh*100
return(crown.stem.ratio)
}
get.crown.diam.ratio <- function(cover, dbh, ba, baf){
#cover = aggregate overstory cover
#diam = stand quadratic mean diameter
#ba = stand basal area count
#baf = basal area factor
if(is.na(baf)){baf=10}
if(baf %in% c(5,10,20,40)){#legacy basal area units
fba = baf*ba
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
}
if(is.na(baf)|baf==2){#metric basal area units
mba = ba*baf
}
m2pertree = 3.141592*(dbh/200)^2
treesperha = mba/m2pertree
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/dbh*100
return(crown.stem.ratio)#crown stem ratio meter per meter
}
get.crown.diam.ratio(0.8,15,5)
get.crown.diam.ratio(0.8,15,5,10)
get.crown.diam.ratio(cover=0.8,dba=15,ba=5,baf=10)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=10)
get.crown.diam.ratio(baf=10,dbh=15,ba=5,cover=0.8)
get.crown.diam.ratio <- function(cover, dbh, ba, baf){
#cover = aggregate overstory cover
#diam = stand quadratic mean diameter
#ba = stand basal area count
#baf = basal area factor
if(is.null(baf)){baf=10}
if(baf %in% c(5,10,20,40)){#legacy basal area units
fba = baf*ba
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
}
if(is.na(baf)|baf==2){#metric basal area units
mba = ba*baf
}
m2pertree = 3.141592*(dbh/200)^2
treesperha = mba/m2pertree
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/dbh*100
return(crown.stem.ratio)#crown stem ratio meter per meter
}
get.crown.diam.ratio <- function(cover, dbh, ba, baf){
#cover = aggregate overstory cover
#diam = stand quadratic mean diameter
#ba = stand basal area count
#baf = basal area factor
if(is.null(baf)){baf=10}
if(baf %in% c(5,10,20,40)){#legacy basal area units
fba = baf*ba
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
}
if(is.na(baf)|baf==2){#metric basal area units
mba = ba*baf
}
m2pertree = 3.141592*(dbh/200)^2
treesperha = mba/m2pertree
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/dbh*100
return(crown.stem.ratio)#crown stem ratio meter per meter
}
get.crown.diam.ratio(0.8,15,5)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5)
get.crown.diam.ratio <- function(cover, dbh, ba, baf=10){
#cover = aggregate overstory cover
#diam = stand quadratic mean diameter
#ba = stand basal area count
#baf = basal area factor
if(baf %in% c(5,10,20,40)){#legacy basal area units
fba = baf*ba
actoha = 43560*0.3048^2/10000
ft2tom2 = 0.3048^2
mba = fba*ft2tom2/actoha
}
if(is.na(baf)|baf==2){#metric basal area units
mba = ba*baf
}
m2pertree = 3.141592*(dbh/200)^2
treesperha = mba/m2pertree
coverpertreeperha = 1-(1-cover)^(1/treesperha)
crown.width = 2*(coverpertreeperha*10000/3.141592)^0.5
crown.width
crown.stem.ratio = crown.width/dbh*100
return(crown.stem.ratio)#crown stem ratio meter per meter
}
get.crown.diam.ratio(0.8,15,5,10)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=10)
get.crown.diam.ratio(0.8,15,5)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=50)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=5)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=40)
get.crown.diam.ratio(cover=0.8,dbh=15,ba=5,baf=41)
library(soilDB)
library(aqp)#load before dplyr
library(stringr)
library(BiodiversityR)
library(cluster)
library(ape)
library(dendextend)
library(dplyr)
library(dynamicTreeCut)
library(rpart)
library(rpart.plot)
library(goeveg)
library(proxy)
library(foreign)
library(optpart)
library(dendsort)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Load Veg tables ----
source('processplot.R')
#load clustering functions ----
source('clusterfunctions.R')
#group parameters ----
beta= -0.30
k = 9
d <- vegdist(plotdata, method='bray', binary=FALSE, na.rm=T)
tbeta <- d %>% flexbeta(beta= beta)
tward <- agnes(d, method = 'ward') %>% as.hclust()
t=tbeta
t=tward
# t=dendsort(t)
# dk <- dynamicK(t, d)
# dkward <- dynamicK(tward, d)
# groups <- cutree(t, k = k)
# maxCoreScatter <- dk[dk$nclust %in% k,]$maxcor
# minGap <- (1 - maxCoreScatter) * 3/4
# dyngroups <-
#   cutreeDynamic(t, minClusterSize=1, method = 'hybrid', distM=as.matrix(d),deepSplit=1, maxCoreScatter=maxCoreScatter, minGap=minGap, maxAbsCoreScatter=NULL, minAbsGap=NULL)
# groups=dyngroups
groups <- cutree(t, k = k)
groups <- grouporder(t, groups)
# grouporder <- function(t,groups){
# soilplot <- names(d)
# clust <- unname(groups)
# groupdf <- as.data.frame(cbind(soilplot, clust))
# groupdf$clust <- (as.numeric(as.character(groupdf$clust)))
# torder <- as.data.frame(cbind(trow=t$order))
# torder$torder <- row(torder)[,1]
# newlabels <- as.data.frame(cbind(labels=t$labels))
# newlabels$trow <- row(newlabels)[,1]
# newlabels <- merge(newlabels, groupdf, by.x='labels', by.y ='soilplot')
# newlabels <- merge(newlabels, torder, by='trow')
#
# grouporder <- newlabels %>% group_by(clust)  %>%  summarise(thisorder = min(torder))
# grouporder$newgroup <- order(order(grouporder$thisorder))
# newlabels <- merge(newlabels, grouporder, by='clust')
# newgroups <- newlabels$newgroup
# names(newgroups) <- newlabels$labels
# return(newgroups)
# }
# newlabels$newlabels <- paste(newlabels$clust, newlabels$newlabels)
# newlabels <- newlabels[order(newlabels$row),1]
# newtree <- t
# newtree$labels <- newlabels
soilplot <- names(d)
clust <- unname(groups)
groupdf <- as.data.frame(cbind(soilplot, clust))
groupdf$clust <- (as.numeric(as.character(groupdf$clust)))
torder <- as.data.frame(cbind(trow=t$order))
torder$torder <- row(torder)[,1]
newlabels <- as.data.frame(cbind(labels=t$labels))
newlabels$trow <- row(newlabels)[,1]
newlabels <- merge(newlabels, groupdf, by.x='labels', by.y ='soilplot')
newlabels <- merge(newlabels, torder, by='trow')
grouporder <- newlabels %>% group_by(clust)  %>%  summarise(thisorder = min(torder))
grouporder$newgroup <- order(order(grouporder$thisorder))
newlabels <- merge(newlabels, grouporder, by='clust')
newgroups <- newlabels$newgroup
names(newgroups) <- newlabels$labels
View(newlabels)
#group parameters ----
beta= -0.30
k = 9
d <- vegdist(plotdata, method='bray', binary=FALSE, na.rm=T)
tbeta <- d %>% flexbeta(beta= beta)
tward <- agnes(d, method = 'ward') %>% as.hclust()
t=tbeta
t=tward
# t=dendsort(t)
# dk <- dynamicK(t, d)
# dkward <- dynamicK(tward, d)
# groups <- cutree(t, k = k)
# maxCoreScatter <- dk[dk$nclust %in% k,]$maxcor
# minGap <- (1 - maxCoreScatter) * 3/4
# dyngroups <-
#   cutreeDynamic(t, minClusterSize=1, method = 'hybrid', distM=as.matrix(d),deepSplit=1, maxCoreScatter=maxCoreScatter, minGap=minGap, maxAbsCoreScatter=NULL, minAbsGap=NULL)
# groups=dyngroups
groups <- cutree(t, k = k)
soilplot <- names(d)
clust <- unname(groups)
groupdf <- as.data.frame(cbind(soilplot, clust))
groupdf$clust <- (as.numeric(as.character(groupdf$clust)))
torder <- as.data.frame(cbind(trow=t$order))
torder$torder <- row(torder)[,1]
newlabels <- as.data.frame(cbind(labels=t$labels))
newlabels$trow <- row(newlabels)[,1]
newlabels <- merge(newlabels, groupdf, by.x='labels', by.y ='soilplot')
newlabels <- merge(newlabels, torder, by='trow')
grouporder <- newlabels %>% group_by(clust)  %>%  summarise(thisorder = min(torder))
grouporder$newgroup <- order(order(grouporder$thisorder))
newlabels <- merge(newlabels, grouporder, by='clust')
newgroups <- newlabels$newgroup
names(newgroups) <- newlabels$labels
newlabels <- newlabels[order(newlabels$trow),]
source('clusterfunctions.R')
#group parameters ----
beta= -0.30
k = 9
d <- vegdist(plotdata, method='bray', binary=FALSE, na.rm=T)
tbeta <- d %>% flexbeta(beta= beta)
tward <- agnes(d, method = 'ward') %>% as.hclust()
t=tbeta
t=tward
# t=dendsort(t)
# dk <- dynamicK(t, d)
# dkward <- dynamicK(tward, d)
# groups <- cutree(t, k = k)
# maxCoreScatter <- dk[dk$nclust %in% k,]$maxcor
# minGap <- (1 - maxCoreScatter) * 3/4
# dyngroups <-
#   cutreeDynamic(t, minClusterSize=1, method = 'hybrid', distM=as.matrix(d),deepSplit=1, maxCoreScatter=maxCoreScatter, minGap=minGap, maxAbsCoreScatter=NULL, minAbsGap=NULL)
# groups=dyngroups
groups <- cutree(t, k = k)
groups <- grouporder(t, groups)
# grouporder <- function(t,groups){
# soilplot <- names(d)
# clust <- unname(groups)
# groupdf <- as.data.frame(cbind(soilplot, clust))
# groupdf$clust <- (as.numeric(as.character(groupdf$clust)))
# torder <- as.data.frame(cbind(trow=t$order))
# torder$torder <- row(torder)[,1]
# newlabels <- as.data.frame(cbind(labels=t$labels))
# newlabels$trow <- row(newlabels)[,1]
# newlabels <- merge(newlabels, groupdf, by.x='labels', by.y ='soilplot')
# newlabels <- merge(newlabels, torder, by='trow')
#
# grouporder <- newlabels %>% group_by(clust)  %>%  summarise(thisorder = min(torder))
# grouporder$newgroup <- order(order(grouporder$thisorder))
# newlabels <- merge(newlabels, grouporder, by='clust')
# newgroups <- newlabels$newgroup
# names(newgroups) <- newlabels$labels
# return(newgroups)
# }
# newlabels$newlabels <- paste(newlabels$clust, newlabels$newlabels)
# newlabels <- newlabels[order(newlabels$row),1]
# newtree <- t
# newtree$labels <- newlabels
if (T){
a <- 'flex'
makeplot(a,d,tbeta,k)
}
if (T){
a <- 'ward'
makeplot(a,d,tward,k)
}
if (T){
a <- 'regroup'
makeplotgroup(a,d,tward,groups)
}
source('groupplotsummary.R')
Com.Structure[order(as.numeric(as.character(Com.Structure$cluster))),c("cluster", "association", "WetStructure")]
source('clusterfunctions.R')
#group parameters ----
beta= -0.30
k = 9
d <- vegdist(plotdata, method='bray', binary=FALSE, na.rm=T)
tbeta <- d %>% flexbeta(beta= beta)
tward <- agnes(d, method = 'ward') %>% as.hclust()
t=tbeta
t=tward
# t=dendsort(t)
# dk <- dynamicK(t, d)
# dkward <- dynamicK(tward, d)
# groups <- cutree(t, k = k)
# maxCoreScatter <- dk[dk$nclust %in% k,]$maxcor
# minGap <- (1 - maxCoreScatter) * 3/4
# dyngroups <-
#   cutreeDynamic(t, minClusterSize=1, method = 'hybrid', distM=as.matrix(d),deepSplit=1, maxCoreScatter=maxCoreScatter, minGap=minGap, maxAbsCoreScatter=NULL, minAbsGap=NULL)
# groups=dyngroups
groups <- cutree(t, k = k)
groups <- grouporder(t, groups)
# grouporder <- function(t,groups){
# soilplot <- names(d)
# clust <- unname(groups)
# groupdf <- as.data.frame(cbind(soilplot, clust))
# groupdf$clust <- (as.numeric(as.character(groupdf$clust)))
# torder <- as.data.frame(cbind(trow=t$order))
# torder$torder <- row(torder)[,1]
# newlabels <- as.data.frame(cbind(labels=t$labels))
# newlabels$trow <- row(newlabels)[,1]
# newlabels <- merge(newlabels, groupdf, by.x='labels', by.y ='soilplot')
# newlabels <- merge(newlabels, torder, by='trow')
#
# grouporder <- newlabels %>% group_by(clust)  %>%  summarise(thisorder = min(torder))
# grouporder$newgroup <- order(order(grouporder$thisorder))
# newlabels <- merge(newlabels, grouporder, by='clust')
# newgroups <- newlabels$newgroup
# names(newgroups) <- newlabels$labels
# return(newgroups)
# }
# newlabels$newlabels <- paste(newlabels$clust, newlabels$newlabels)
# newlabels <- newlabels[order(newlabels$row),1]
# newtree <- t
# newtree$labels <- newlabels
if (T){
a <- 'flex'
makeplot(a,d,tbeta,k)
}
if (T){
a <- 'ward'
makeplot(a,d,tward,k)
}
if (T){
a <- 'regroup'
makeplotgroup(a,d,tward,groups)
}
source('groupplotsummary.R')
Com.Structure[order(as.numeric(as.character(Com.Structure$cluster))),c("cluster", "association", "WetStructure")]
